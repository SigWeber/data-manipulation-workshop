[
["index.html", "Data manipulation in R (online workshop) 1 Introduction", " Data manipulation in R (online workshop) Sigrid Weber 1 Introduction Data manipulation - or the process of cleaning, organising and preparing your data for further analysis - is required for most projects involving real-world datasets. This workshop teaches you how to use R to manipulate raw data and prepare it for analysis. We will cover the following topics: The grammar of data manipulation Merging multiple datasets Creating subsets of data using filters Reshaping data between long and wide formats Summarising data with group-wise operation Setting up data pipelines in dplyr for efficient data manipulation The workshop is designed for individuals who are already familiar with R but wish to learn efficient techniques for data manipulation. The workshop will be a combination of coding demonstrations by me and excercises for you to try on your own computer. Ideally, you make sure that R and RStudio are installed. You may also want to install the package tidyverse. Instructions how to do so can be found in the section 3 Getting started. "],
["resources.html", "2 Resources", " 2 Resources Google (in particular Stack Overflow) Tidy Data Tidyverse Data Wrangling with dplyr and tidyr Cheat Sheet R for Data Science Advanced R Data manipulation in R with dplyr Hands-on dplyr tutorial for faster data manipulation in R "],
["getting-started.html", "3 Getting Started 3.1 Prerequisites 3.2 Software Requirements 3.3 Required Packages", " 3 Getting Started 3.1 Prerequisites Basic knowledge of working with datasets in R is essential. This course assumes that you’re comfortable with reading datasets, working with script files, and navigating in RStudio. 3.2 Software Requirements 3.2.1 R and RStudio Recent versions of R (version 3.2 or newer) and RStudio (version 1.0 above) are required. You can download the latest versions from the links below: Download R Download RStudio You can find out the version of R installed by typing version at the console: version ## _ ## platform x86_64-w64-mingw32 ## arch x86_64 ## os mingw32 ## system x86_64, mingw32 ## status ## major 4 ## minor 0.0 ## year 2020 ## month 04 ## day 24 ## svn rev 78286 ## language R ## version.string R version 4.0.0 (2020-04-24) ## nickname Arbor Day 3.3 Required Packages This workshop relies on three packages: dplyr, tidyr, and readr. There are two ways to install these packages: 3.3.1 Option 1: Use tidyverse You can either install these two packages individually or use tidyverse. The tidyverse package is a collection of packages used for data manipulation and visualization. In addition to dplyr, tidyr, and readr, it also includes the following: ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dbplyr&quot; &quot;dplyr&quot; &quot;forcats&quot; &quot;ggplot2&quot; ## [8] &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; ## [15] &quot;pillar&quot; &quot;purrr&quot; &quot;readr&quot; &quot;readxl&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [22] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; &quot;tidyverse&quot; You can install tidyverse using the install.packages() function: install.packages(&quot;tidyverse&quot;) You can find out the version of tidyverse installed using the packageVersion() function: packageVersion(&quot;tidyverse&quot;) ## [1] &#39;1.3.0&#39; To update tidyverse packages, you can use the tidyverse_update() function: tidyverse::tidyverse_update() 3.3.2 Option 2: Install Individual Packages If you encounter any problems installing tidyverse, then the other option is to install dplyr, tidyr, and readr individually. install.packages(&quot;dplyr&quot;) install.packages(&quot;tidyr&quot;) install.packages(&quot;readr&quot;) "],
["basic-operations.html", "4 Basic Operations 4.1 Data pipelines 4.2 Dataset 4.3 Select 4.4 Filter 4.5 Arrange 4.6 Mutate 4.7 Summarise 4.8 Unite 4.9 Separate", " 4 Basic Operations Let’s start off by creating a new R script and loading tidyverse: library(tidyverse) Clear everything to make sure there’s nothing leftover in our environment rm(list = ls()) 4.1 Data pipelines Dplyr makes it easy to “chain” functions together using the pipe operator %&gt;%. The following diagram illustrates the general concept of pipes where data flows from one pipe to another until all the processing is completed. The syntax of the pipe operator %&gt;% might appear unusual at first, but once you get used to it you’ll start to appreciate its power and flexibility. 4.2 Dataset We’re using a dataset of flight departures from Houston in 2011. Filename Description flights.csv Flight departures from Houston in 2011 weather.csv Hourly weather planes.csv Metadata for planes airports.csv Metadata for airports We’re going to use the readr package which provides improved functions for reading datasets from files. Instead of the usual read.csv() function, we’ll use the read_csv() function from readr. flights &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/flights.csv&quot;) Now let’s examine the dataset flights ## # A tibble: 227,496 x 15 ## date hour minute dep arr dep_delay arr_delay carrier flight origin dest plane ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 01/0~ 14 0 1400 1500 0 -10 AA 428 IAH DFW N576~ ## 2 02/0~ 14 1 1401 1501 1 -9 AA 428 IAH DFW N557~ ## 3 03/0~ 13 52 1352 1502 -8 -8 AA 428 IAH DFW N541~ ## 4 04/0~ 14 3 1403 1513 3 3 AA 428 IAH DFW N403~ ## 5 05/0~ 14 5 1405 1507 5 -3 AA 428 IAH DFW N492~ ## 6 06/0~ 13 59 1359 1503 -1 -7 AA 428 IAH DFW N262~ ## 7 07/0~ 13 59 1359 1509 -1 -1 AA 428 IAH DFW N493~ ## 8 08/0~ 13 55 1355 1454 -5 -16 AA 428 IAH DFW N477~ ## 9 09/0~ 14 43 1443 1554 43 44 AA 428 IAH DFW N476~ ## 10 10/0~ 14 43 1443 1553 43 43 AA 428 IAH DFW N504~ ## # ... with 227,486 more rows, and 3 more variables: cancelled &lt;dbl&gt;, time &lt;dbl&gt;, dist &lt;dbl&gt; Notice that because we used read_csv(), the data frame we received now prints nicely without having to use the head() function and does not clutter your screen. 4.3 Select The select function is used to select columns. Select the destination, duration and distance columns (dest, time and dist) flights %&gt;% select(dest, time, dist) ## # A tibble: 227,496 x 3 ## dest time dist ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DFW 40 224 ## 2 DFW 45 224 ## 3 DFW 48 224 ## 4 DFW 39 224 ## 5 DFW 44 224 ## 6 DFW 45 224 ## 7 DFW 43 224 ## 8 DFW 40 224 ## 9 DFW 41 224 ## 10 DFW 45 224 ## # ... with 227,486 more rows Add the arrival delay (arr_delay) and departure delay (dep_delay) columns as well. flights %&gt;% select(dest, time, dist, arr_delay, dep_delay) ## # A tibble: 227,496 x 5 ## dest time dist arr_delay dep_delay ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DFW 40 224 -10 0 ## 2 DFW 45 224 -9 1 ## 3 DFW 48 224 -8 -8 ## 4 DFW 39 224 3 3 ## 5 DFW 44 224 -3 5 ## 6 DFW 45 224 -7 -1 ## 7 DFW 43 224 -1 -1 ## 8 DFW 40 224 -16 -5 ## 9 DFW 41 224 44 43 ## 10 DFW 45 224 43 43 ## # ... with 227,486 more rows Other ways to do the same flights %&gt;% select(dest, time, dist, ends_with(&quot;delay&quot;)) ## # A tibble: 227,496 x 5 ## dest time dist dep_delay arr_delay ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DFW 40 224 0 -10 ## 2 DFW 45 224 1 -9 ## 3 DFW 48 224 -8 -8 ## 4 DFW 39 224 3 3 ## 5 DFW 44 224 5 -3 ## 6 DFW 45 224 -1 -7 ## 7 DFW 43 224 -1 -1 ## 8 DFW 40 224 -5 -16 ## 9 DFW 41 224 43 44 ## 10 DFW 45 224 43 43 ## # ... with 227,486 more rows and … flights %&gt;% select(dest, time, dist, contains(&quot;delay&quot;)) ## # A tibble: 227,496 x 5 ## dest time dist dep_delay arr_delay ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DFW 40 224 0 -10 ## 2 DFW 45 224 1 -9 ## 3 DFW 48 224 -8 -8 ## 4 DFW 39 224 3 3 ## 5 DFW 44 224 5 -3 ## 6 DFW 45 224 -1 -7 ## 7 DFW 43 224 -1 -1 ## 8 DFW 40 224 -5 -16 ## 9 DFW 41 224 43 44 ## 10 DFW 45 224 43 43 ## # ... with 227,486 more rows Select all columns from date to arr flights %&gt;% select(date:arr) ## # A tibble: 227,496 x 5 ## date hour minute dep arr ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01/01/2011 12:00 14 0 1400 1500 ## 2 02/01/2011 12:00 14 1 1401 1501 ## 3 03/01/2011 12:00 13 52 1352 1502 ## 4 04/01/2011 12:00 14 3 1403 1513 ## 5 05/01/2011 12:00 14 5 1405 1507 ## 6 06/01/2011 12:00 13 59 1359 1503 ## 7 07/01/2011 12:00 13 59 1359 1509 ## 8 08/01/2011 12:00 13 55 1355 1454 ## 9 09/01/2011 12:00 14 43 1443 1554 ## 10 10/01/2011 12:00 14 43 1443 1553 ## # ... with 227,486 more rows Select all except plane column using the minus sign flights %&gt;% select(-plane) ## # A tibble: 227,496 x 14 ## date hour minute dep arr dep_delay arr_delay carrier flight origin dest cancelled ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 01/0~ 14 0 1400 1500 0 -10 AA 428 IAH DFW 0 ## 2 02/0~ 14 1 1401 1501 1 -9 AA 428 IAH DFW 0 ## 3 03/0~ 13 52 1352 1502 -8 -8 AA 428 IAH DFW 0 ## 4 04/0~ 14 3 1403 1513 3 3 AA 428 IAH DFW 0 ## 5 05/0~ 14 5 1405 1507 5 -3 AA 428 IAH DFW 0 ## 6 06/0~ 13 59 1359 1503 -1 -7 AA 428 IAH DFW 0 ## 7 07/0~ 13 59 1359 1509 -1 -1 AA 428 IAH DFW 0 ## 8 08/0~ 13 55 1355 1454 -5 -16 AA 428 IAH DFW 0 ## 9 09/0~ 14 43 1443 1554 43 44 AA 428 IAH DFW 0 ## 10 10/0~ 14 43 1443 1553 43 43 AA 428 IAH DFW 0 ## # ... with 227,486 more rows, and 2 more variables: time &lt;dbl&gt;, dist &lt;dbl&gt; 4.4 Filter The filter() function returns rows with matching conditions. We can find all flights to Boston (BOS) like this: flights %&gt;% filter(dest == &quot;BOS&quot;) ## # A tibble: 1,752 x 15 ## date hour minute dep arr dep_delay arr_delay carrier flight origin dest plane ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 31/0~ 7 35 735 1220 0 4 CO 282 IAH BOS N792~ ## 2 31/0~ 10 47 1047 1526 -3 -5 CO 382 IAH BOS N362~ ## 3 31/0~ 13 5 1305 1746 0 -3 CO 482 IAH BOS N785~ ## 4 31/0~ 19 1 1901 2332 6 -1 CO 582 IAH BOS N196~ ## 5 31/0~ 15 50 1550 2012 0 -25 CO 682 IAH BOS N785~ ## 6 30/0~ 10 46 1046 1518 -4 -8 CO 382 IAH BOS N762~ ## 7 30/0~ 13 19 1319 1811 14 22 CO 482 IAH BOS N775~ ## 8 30/0~ 19 9 1909 23 14 50 CO 582 IAH BOS N166~ ## 9 30/0~ 15 53 1553 2030 3 -7 CO 682 IAH BOS N262~ ## 10 29/0~ 7 40 740 1227 5 16 CO 282 IAH BOS N352~ ## # ... with 1,742 more rows, and 3 more variables: cancelled &lt;dbl&gt;, time &lt;dbl&gt;, dist &lt;dbl&gt; Let’s build on the previous exercise and find all flights to Boston (BOS) and select only the dest, time, dist columns: flights %&gt;% select(dest, time, dist) %&gt;% filter(dest == &quot;BOS&quot;) ## # A tibble: 1,752 x 3 ## dest time dist ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BOS 195 1597 ## 2 BOS 188 1597 ## 3 BOS 190 1597 ## 4 BOS 188 1597 ## 5 BOS 180 1597 ## 6 BOS 190 1597 ## 7 BOS 185 1597 ## 8 BOS 198 1597 ## 9 BOS 194 1597 ## 10 BOS 203 1597 ## # ... with 1,742 more rows Now let’s do the filter first and then select the columns flights %&gt;% filter(dest == &quot;BOS&quot;) %&gt;% select(dest, time, dist) ## # A tibble: 1,752 x 3 ## dest time dist ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BOS 195 1597 ## 2 BOS 188 1597 ## 3 BOS 190 1597 ## 4 BOS 188 1597 ## 5 BOS 180 1597 ## 6 BOS 190 1597 ## 7 BOS 185 1597 ## 8 BOS 198 1597 ## 9 BOS 194 1597 ## 10 BOS 203 1597 ## # ... with 1,742 more rows In this case the order doesn’t matter, but when using pipes make sure you understand that each function is executed in sequence and the results are then fed to the next one. 4.4.1 Exercise Find all flights that match the following conditions: To SFO or OAK In January Delayed departure by more than an hour Departure delay more than twice the arrival delay Here’s a brief summary of operators you can use: Comparison Operators Operator Description Example (assume x is 5) Result &gt; greater than x &gt; 5 FALSE &gt;= greater than or equal to x &gt;= 5 TRUE &lt; less than x &lt; 5 FALSE &lt;= less than or equal to x &lt;= 5 TRUE == equal to x == 5 TRUE != not equal to x != 5 FALSE Logical Operators Operator Description ! not | or &amp; and Other Operators Operator Description Example (assume x is 5) Result %in% check element in a vector x %in% c(1, 3, 5, 7)x %in% c(2, 4, 6, 8) TRUEFALSE 4.5 Arrange The arrange() function is used to sort the rows based on one or more columns flights %&gt;% arrange(dest) ## # A tibble: 227,496 x 15 ## date hour minute dep arr dep_delay arr_delay carrier flight origin dest plane ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 31/0~ 17 33 1733 1901 -2 -4 CO 1715 IAH ABQ N196~ ## 2 30/0~ 17 50 1750 1913 15 8 CO 1715 IAH ABQ N196~ ## 3 29/0~ 17 32 1732 1837 -3 -23 CO 1715 IAH ABQ N146~ ## 4 28/0~ 17 33 1733 1848 -2 -17 CO 1715 IAH ABQ N146~ ## 5 27/0~ 17 41 1741 1854 6 -11 CO 1715 IAH ABQ N176~ ## 6 26/0~ 17 32 1732 1853 -3 -12 CO 1715 IAH ABQ N146~ ## 7 25/0~ 17 29 1729 1858 -6 -7 CO 1715 IAH ABQ N146~ ## 8 24/0~ 17 34 1734 1845 -1 -20 CO 1715 IAH ABQ N166~ ## 9 23/0~ 17 35 1735 1853 0 -12 CO 1715 IAH ABQ N196~ ## 10 22/0~ 17 33 1733 1843 -2 -17 CO 1715 IAH ABQ N196~ ## # ... with 227,486 more rows, and 3 more variables: cancelled &lt;dbl&gt;, time &lt;dbl&gt;, dist &lt;dbl&gt; 4.5.1 Exercise Order flights by departure date and time Which flights were most delayed? Which flights caught up the most time during flight? 4.6 Mutate The mutate() function is used to create new variables. Up until now we’ve only been examining the dataset but haven’t made any changes to it. All our functions so far have simply displayed the results on screen but haven’t created or modified existing variables. Let’s see how we can create a new variable called speed based on the distance and duration in the flights dataframe. In this exercise we’re adding a new variable to an existing dataframe so we’ll just overwrite the flights variable with the one that has a speed column flights &lt;- flights %&gt;% mutate(speed = dist / (time / 60)) 4.6.1 Exercise Add a variable to show how much time was made up (or lost) during flight 4.7 Summarise Let’s count the number of flights departing each day. flights %&gt;% group_by(date) %&gt;% summarise(count = n()) ## # A tibble: 365 x 2 ## date count ## &lt;chr&gt; &lt;int&gt; ## 1 01/01/2011 12:00 552 ## 2 01/02/2011 12:00 577 ## 3 01/03/2011 12:00 591 ## 4 01/04/2011 12:00 684 ## 5 01/05/2011 12:00 619 ## 6 01/06/2011 12:00 591 ## 7 01/07/2011 12:00 699 ## 8 01/08/2011 12:00 699 ## 9 01/09/2011 12:00 670 ## 10 01/10/2011 12:00 490 ## # ... with 355 more rows Here’s a nice little trick. You can use View() to look at the results of a pipe operation without creating new variables. flights %&gt;% group_by(date) %&gt;% summarise(count = n()) %&gt;% View() Of course, often times we’d want to save the summary in a variable for further analysis. Let’s find the average departure delay for each destination delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarise(mean = mean(dep_delay)) delays ## # A tibble: 116 x 2 ## dest mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABQ NA ## 2 AEX NA ## 3 AGS 10 ## 4 AMA NA ## 5 ANC 25.0 ## 6 ASE NA ## 7 ATL NA ## 8 AUS NA ## 9 AVL NA ## 10 BFL NA ## # ... with 106 more rows 4.7.1 Exercise What’s wrong with the results above, and how would you fix the problem? Can you think of using filter to solve the problem? How many different destinations can you fly to from Houston? Which destinations have the highest average delays? 4.8 Unite The unite function is useful for combining multiple columns together. In the example below, we join the carrier and flight to create a unique flight_id column. flights %&gt;% unite(flight_id, carrier, flight, sep = &quot;-&quot;, remove = FALSE) %&gt;% select(date, carrier, flight, flight_id) ## # A tibble: 227,496 x 4 ## date carrier flight flight_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 01/01/2011 12:00 AA 428 AA-428 ## 2 02/01/2011 12:00 AA 428 AA-428 ## 3 03/01/2011 12:00 AA 428 AA-428 ## 4 04/01/2011 12:00 AA 428 AA-428 ## 5 05/01/2011 12:00 AA 428 AA-428 ## 6 06/01/2011 12:00 AA 428 AA-428 ## 7 07/01/2011 12:00 AA 428 AA-428 ## 8 08/01/2011 12:00 AA 428 AA-428 ## 9 09/01/2011 12:00 AA 428 AA-428 ## 10 10/01/2011 12:00 AA 428 AA-428 ## # ... with 227,486 more rows 4.9 Separate The separate function works the other way around by splitting a single column into multiple columns. Let’s split the date column into separate date and time columns. flights %&gt;% separate(date, c(&quot;date&quot;, &quot;time&quot;), sep = &quot; &quot;) ## # A tibble: 227,496 x 16 ## date time hour minute dep arr dep_delay arr_delay carrier flight origin dest plane ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 01/0~ 12:00 14 0 1400 1500 0 -10 AA 428 IAH DFW N576~ ## 2 02/0~ 12:00 14 1 1401 1501 1 -9 AA 428 IAH DFW N557~ ## 3 03/0~ 12:00 13 52 1352 1502 -8 -8 AA 428 IAH DFW N541~ ## 4 04/0~ 12:00 14 3 1403 1513 3 3 AA 428 IAH DFW N403~ ## 5 05/0~ 12:00 14 5 1405 1507 5 -3 AA 428 IAH DFW N492~ ## 6 06/0~ 12:00 13 59 1359 1503 -1 -7 AA 428 IAH DFW N262~ ## 7 07/0~ 12:00 13 59 1359 1509 -1 -1 AA 428 IAH DFW N493~ ## 8 08/0~ 12:00 13 55 1355 1454 -5 -16 AA 428 IAH DFW N477~ ## 9 09/0~ 12:00 14 43 1443 1554 43 44 AA 428 IAH DFW N476~ ## 10 10/0~ 12:00 14 43 1443 1553 43 43 AA 428 IAH DFW N504~ ## # ... with 227,486 more rows, and 3 more variables: cancelled &lt;dbl&gt;, dist &lt;dbl&gt;, speed &lt;dbl&gt; 4.9.1 Exercise Split the date column into year, month, and day columns Ensure that the year, month, and day columns are of type integer (NOT character) HINT: Use online help for separate for an easy way to do this "],
["merging-datasets.html", "5 Merging Datasets 5.1 Left Join 5.2 Right Join 5.3 Inner Join 5.4 Full Join 5.5 Different Column Names 5.6 Exercise", " 5 Merging Datasets Let’s start by loading the tidyverse package library(tidyverse) Clear everything to make sure there’s nothing leftover in our environment rm(list = ls()) Next, we load three datasets of universities, cities, and states. universities &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/universities.csv&quot;) cities &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/cities.csv&quot;) states &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/states.csv&quot;) Let’s see how we can merge the universities dataset with the cities dataset. ## Warning: `data_frame()` is deprecated as of tibble 1.1.0. ## Please use `tibble()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. 5.1 Left Join universities %&gt;% left_join(cities, by = &quot;city&quot;) 5.2 Right Join universities %&gt;% right_join(cities, by = &quot;city&quot;) 5.3 Inner Join universities %&gt;% inner_join(cities, by = &quot;city&quot;) 5.4 Full Join universities %&gt;% full_join(cities, by = &quot;city&quot;) 5.5 Different Column Names In the previous example both our datasets included a column named city. But what if the names of the columns in the two datasets were not the same? For example, let’s take a look at the states table: What if we were to merge the cities dataset with states? One option would be to rename the columns so their names would match, but you don’t really need to do that. You can simply tell the join functions the mapping between the different names. cities %&gt;% left_join(states, by = c(&quot;state&quot; = &quot;statename&quot;)) In the above example, we’re telling left_join() to merge using the state column from the cities data frame and statename column from the states data frame. 5.6 Exercise Load the following datasets: presidents &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/presidents.csv&quot;) presidents_home &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/presidents_home.csv&quot;) The datasets include names of U.S. presidents: Merge the two datasets so that it ONLY includes observations that exist in BOTH the datasets. There should be no missing values or NA in the merged table. The results should match the following: Merge the two datasets so that it includes ALL the observations from both the datasets. Some TookOffice, LeftOffice and HomeState values will be NA and that’s ok. The results should match the following: Merge the two datasets so that ALL observations from the presidents datasets are included. Some HomeState values will be NA and that’s ok. The results should match the following: Merge the two datasets so that ALL observations from the presidents_home datasets are included. Some TookOffice and LeftOffice values will be NA and that’s ok. The results should match the following: "],
["reshaping.html", "6 Reshaping", " 6 Reshaping It’s fairly common for datasets from public sources to come in formats that need to be reshaped. The World Development Indicators (WDI) is one such dataset that requires reshaping before we can analyse it. Let’s go over the steps to see how we can reshape the WDI dataset. Let’s start by loading the tidyverse package first. library(tidyverse) Clear everything to make sure there’s nothing leftover in our environment rm(list = ls()) We’re using a small sample of the WDI dataset here to simplify the tasks. Let’s load the dataset and see what it looks like. wdi &lt;- read_csv(&quot;https://raw.githubusercontent.com/SigWeber/data-manipulation-workshop/master/data/wdi.csv&quot;, na = &quot;..&quot;) wdi ## # A tibble: 5 x 7 ## `¬Series.Name` Series.Code Country.Name Country.Code X1995.YR1995 X2000.YR2000 X2005.YR2005 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maternal mortal~ SH.STA.MMRT &quot;France&quot; &quot;FRA&quot; 15 12 10 ## 2 Maternal mortal~ SH.STA.MMRT &quot;Spain&quot; &quot;ESP&quot; 6 5 5 ## 3 Maternal mortal~ SH.STA.MMRT &quot;&quot; &quot;&quot; NA NA NA ## 4 Health expendit~ SH.XPD.TOTL~ &quot;France&quot; &quot;FRA&quot; 10.4 10.1 10.9 ## 5 Health expendit~ SH.XPD.TOTL~ &quot;Spain&quot; &quot;ESP&quot; 7.44 7.21 8.29 But ideally, we’d like our data to look something like this: ## # A tibble: 12 x 5 ## Indicator Country.Name Country.Code Year Development.Index ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maternal mortality France FRA 1995 15 ## 2 Maternal mortality France FRA 2000 12 ## 3 Maternal mortality France FRA 2005 10 ## 4 Maternal mortality Spain ESP 1995 6 ## 5 Maternal mortality Spain ESP 2000 5 ## 6 Maternal mortality Spain ESP 2005 5 ## 7 Health expenditure France FRA 1995 10.4 ## 8 Health expenditure France FRA 2000 10.1 ## 9 Health expenditure France FRA 2005 10.9 ## 10 Health expenditure Spain ESP 1995 7.44 ## 11 Health expenditure Spain ESP 2000 7.21 ## 12 Health expenditure Spain ESP 2005 8.29 So, what do we do to achieve this new data format? Note: We want to move away from a wide data frame to a long data frame! Step 1: We can see that some country names and codes are blank, so let’s get rid of them first wdi %&gt;% filter(Country.Code != &quot;&quot;) ## # A tibble: 4 x 7 ## `¬Series.Name` Series.Code Country.Name Country.Code X1995.YR1995 X2000.YR2000 X2005.YR2005 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maternal mortal~ SH.STA.MMRT France FRA 15 12 10 ## 2 Maternal mortal~ SH.STA.MMRT Spain ESP 6 5 5 ## 3 Health expendit~ SH.XPD.TOTL~ France FRA 10.4 10.1 10.9 ## 4 Health expendit~ SH.XPD.TOTL~ Spain ESP 7.44 7.21 8.29 So far so good. Note that we’re not making any changes yet so we can just add one function at a time to the pipeline and check the results. Once we’re satisfied with the results we save them to a variable. Step 2: The dataset contains maternal mortality and health expenditure rates but I really don’t like the variable names and what use do I have for the series code? I want to rename and exclude some variables! wdi %&gt;% filter(Country.Code != &quot;&quot;) %&gt;% select(-Series.Code) %&gt;% rename(Indicator = `¬Series.Name`) ## # A tibble: 4 x 6 ## Indicator Country.Name Country.Code X1995.YR1995 X2000.YR2000 X2005.YR2005 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maternal mortality France FRA 15 12 10 ## 2 Maternal mortality Spain ESP 6 5 5 ## 3 Health expenditure France FRA 10.4 10.1 10.9 ## 4 Health expenditure Spain ESP 7.44 7.21 8.29 That looks already but we still have to tackle our main task: how do we get all data entries for different years into one row instead of 3 columns? We want to put all etnries in the columns starting with an X to be below each other. The function to achieve this is pivot_longer(). All we have to do is to specify the data and to select the columns we want to reformat. However, we still want to know which value of the world development index was achieved in which year. So, we also tell this to the function: wdi %&gt;% filter(Country.Code != &quot;&quot;) %&gt;% select(-Series.Code) %&gt;% rename(Indicator = `¬Series.Name`) %&gt;% pivot_longer(cols = starts_with(&quot;X&quot;), names_to = &quot;Year&quot;, values_to = &quot;Development.Index&quot;) ## # A tibble: 12 x 5 ## Indicator Country.Name Country.Code Year Development.Index ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Maternal mortality France FRA X1995.YR1995 15 ## 2 Maternal mortality France FRA X2000.YR2000 12 ## 3 Maternal mortality France FRA X2005.YR2005 10 ## 4 Maternal mortality Spain ESP X1995.YR1995 6 ## 5 Maternal mortality Spain ESP X2000.YR2000 5 ## 6 Maternal mortality Spain ESP X2005.YR2005 5 ## 7 Health expenditure France FRA X1995.YR1995 10.4 ## 8 Health expenditure France FRA X2000.YR2000 10.1 ## 9 Health expenditure France FRA X2005.YR2005 10.9 ## 10 Health expenditure Spain ESP X1995.YR1995 7.44 ## 11 Health expenditure Spain ESP X2000.YR2000 7.21 ## 12 Health expenditure Spain ESP X2005.YR2005 8.29 Thats already pretty close. The Year column looks ugly but that’s an easy fix. We can use the substring() function to take all the characters from position 2 to 5 and assign it back to the Year column. Since this is the last step we might as well assign the results to a new dataset. wdi_long &lt;- wdi %&gt;% filter(Country.Code != &quot;&quot;) %&gt;% select(-Series.Code) %&gt;% rename(Indicator = `¬Series.Name`) %&gt;% pivot_longer(cols = starts_with(&quot;X&quot;), names_to = &quot;Year&quot;, values_to = &quot;Development.Index&quot;) %&gt;% mutate(Year = as.numeric(substring(Year, 2, 5))) wdi_long ## # A tibble: 12 x 5 ## Indicator Country.Name Country.Code Year Development.Index ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maternal mortality France FRA 1995 15 ## 2 Maternal mortality France FRA 2000 12 ## 3 Maternal mortality France FRA 2005 10 ## 4 Maternal mortality Spain ESP 1995 6 ## 5 Maternal mortality Spain ESP 2000 5 ## 6 Maternal mortality Spain ESP 2005 5 ## 7 Health expenditure France FRA 1995 10.4 ## 8 Health expenditure France FRA 2000 10.1 ## 9 Health expenditure France FRA 2005 10.9 ## 10 Health expenditure Spain ESP 1995 7.44 ## 11 Health expenditure Spain ESP 2000 7.21 ## 12 Health expenditure Spain ESP 2005 8.29 Sometimes, but less often, you will also reshape data to a wide format. That can be achieved with the sibling function pivot_wider() in the tidyverse. Check out the online help for this function if you want to use it. "],
["acknowledgments.html", "7 Acknowledgments", " 7 Acknowledgments Content of this workshop is based on the following: Altaf Ali’s tutorial last year Introduction to dplyr Data manipulation with dplyr, 2014 Hands-on dplyr tutorial for faster data manipulation in R This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. "]
]
